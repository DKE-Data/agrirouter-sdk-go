// Package test_server provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/oapi-codegen/oapi-codegen/v2 version v2.4.0 DO NOT EDIT.
package test_server

import (
	"context"
	"encoding/json"
	"errors"
	"fmt"
	"io"
	"net/http"
	"time"

	"github.com/labstack/echo/v4"
	"github.com/oapi-codegen/runtime"
	strictecho "github.com/oapi-codegen/runtime/strictmiddleware/echo"
	openapi_types "github.com/oapi-codegen/runtime/types"
)

const (
	AgrirouterOauthPRODScopes = "agrirouterOauthPROD.Scopes"
	AgrirouterOauthQAScopes   = "agrirouterOauthQA.Scopes"
)

// Defines values for EndpointCapabilityDirection.
const (
	RECEIVE     EndpointCapabilityDirection = "RECEIVE"
	SEND        EndpointCapabilityDirection = "SEND"
	SENDRECEIVE EndpointCapabilityDirection = "SEND_RECEIVE"
)

// Defines values for EndpointType.
const (
	CommunicationUnit        EndpointType = "communication_unit"
	FarmingSoftware          EndpointType = "farming_software"
	TelemetryPlatform        EndpointType = "telemetry_platform"
	VirtualCommunicationUnit EndpointType = "virtual_communication_unit"
)

// Defines values for ReceiveEventsParamsTypes.
const (
	FILERECEIVED    ReceiveEventsParamsTypes = "FILE_RECEIVED"
	MESSAGERECEIVED ReceiveEventsParamsTypes = "MESSAGE_RECEIVED"
)

// Endpoint defines model for Endpoint.
type Endpoint struct {
	ApplicationId     openapi_types.UUID   `json:"application_id"`
	Capabilities      []EndpointCapability `json:"capabilities"`
	EndpointType      EndpointType         `json:"endpoint_type"`
	ExternalId        string               `json:"external_id"`
	Id                openapi_types.UUID   `json:"id"`
	SoftwareVersionId openapi_types.UUID   `json:"software_version_id"`

	// TenantId The tenant ID of the endpoint
	TenantId string `json:"tenant_id"`
}

// EndpointCapability defines model for EndpointCapability.
type EndpointCapability struct {
	Direction EndpointCapabilityDirection `json:"direction"`

	// MessageType The message type that the endpoint can send or receive.
	// See available types here:
	// https://docs.agrirouter.com/agrirouter-interface-documentation/latest/tmt/overview.html
	MessageType string `json:"message_type"`
}

// EndpointCapabilityDirection defines model for EndpointCapability.Direction.
type EndpointCapabilityDirection string

// EndpointSubscription defines model for EndpointSubscription.
type EndpointSubscription struct {
	// MessageType The message type that the endpoint is subscribed to.
	// See available types here:
	// https://docs.agrirouter.com/agrirouter-interface-documentation/latest/tmt/overview.html
	MessageType string `json:"message_type"`
}

// EndpointType defines model for EndpointType.
type EndpointType string

// FileReceivedEventData Data structure for FILE_RECEIVED events. This event shall arrive whenever a big file transfer
// has completed in its entirety, i.e when big payload was sent as several message chunks, this
// event would be sent last when the complete payload is received.
type FileReceivedEventData struct {
	EventType string `json:"event_type"`

	// Filename Optional name of the file that is attached to messages as metadata.
	Filename *string `json:"filename,omitempty"`

	// Payload The payload of the file, base64 encoded. Only one of `payload` or `payload_uri` would be present.
	Payload *[]byte `json:"payload,omitempty"`

	// PayloadUri The URI to access the payload. May have hostname that is different from
	// the API server, as payloads may be served from a different server or CDN.
	// Clients MUST use provided URI as is without any modifications.
	// If event embeds payload directly, this field would be absent.
	PayloadUri *PayloadURI `json:"payload_uri,omitempty"`
}

// GenericEventData defines model for GenericEventData.
type GenericEventData struct {
	union json.RawMessage
}

// MessageReceivedEventData Data structure for MESSAGE_RECEIVED events. This event would arrive whenever application
// got a message routed to one of its endpoints.
type MessageReceivedEventData struct {
	// AppMessageId The application message ID of the received message, generated based on application input.
	AppMessageId string `json:"app_message_id"`
	EventType    string `json:"event_type"`

	// Filename Optional name of the file that is attached to messages as metadata.
	Filename *string `json:"filename,omitempty"`

	// Id The agrirouter message ID of the received message, generated by agrirouter.
	Id openapi_types.UUID `json:"id"`

	// MessageType The message type of the received message.
	// See available types here:
	// https://docs.agrirouter.com/agrirouter-interface-documentation/latest/tmt/overview.html
	MessageType string `json:"message_type"`

	// Payload The payload of the message, base64 encoded. Only one of `payload` or `payload_uri` would be present.
	Payload *[]byte `json:"payload,omitempty"`

	// PayloadUri The URI to access the payload. May have hostname that is different from
	// the API server, as payloads may be served from a different server or CDN.
	// Clients MUST use provided URI as is without any modifications.
	// If event embeds payload directly, this field would be absent.
	PayloadUri *PayloadURI `json:"payload_uri,omitempty"`

	// ReceivedAt The timestamp when the message was received by agrirouter.
	ReceivedAt *time.Time `json:"received_at,omitempty"`

	// ReceivingEndpointId Internally-generated agrirouter ID of the receiving endpoint.
	ReceivingEndpointId openapi_types.UUID `json:"receiving_endpoint_id"`

	// SentAt The timestamp when the message was sent by sending application.
	SentAt time.Time `json:"sent_at"`
}

// PayloadURI The URI to access the payload. May have hostname that is different from
// the API server, as payloads may be served from a different server or CDN.
// Clients MUST use provided URI as is without any modifications.
// If event embeds payload directly, this field would be absent.
type PayloadURI = string

// PutEndpointRequest defines model for PutEndpointRequest.
type PutEndpointRequest struct {
	// ApplicationId The ID of the application that owns the endpoint
	ApplicationId openapi_types.UUID `json:"application_id"`

	// Capabilities The effective capabilities of the endpoint, must be subset of the capabilities of software version.
	Capabilities []EndpointCapability `json:"capabilities"`
	EndpointType EndpointType         `json:"endpoint_type"`

	// SoftwareVersionId The ID of the software version that owns the endpoint
	SoftwareVersionId openapi_types.UUID     `json:"software_version_id"`
	Subscriptions     []EndpointSubscription `json:"subscriptions"`
}

// XAgrirouterTenantId defines model for x-agrirouter-tenant-id.
type XAgrirouterTenantId = openapi_types.UUID

// PutEndpointParams defines parameters for PutEndpoint.
type PutEndpointParams struct {
	// XAgrirouterTenantId The farmer's tenant ID in relation to which communication is done.
	XAgrirouterTenantId XAgrirouterTenantId `json:"x-agrirouter-tenant-id"`
}

// ReceiveEventsParams defines parameters for ReceiveEvents.
type ReceiveEventsParams struct {
	// Types Events type filter, if provided would limit the events returned to only those of the specified types.
	// If not provided, all supported events will be streamed.
	Types *[]ReceiveEventsParamsTypes `form:"types,omitempty" json:"types,omitempty"`
}

// ReceiveEventsParamsTypes defines parameters for ReceiveEvents.
type ReceiveEventsParamsTypes string

// SendMessagesParams defines parameters for SendMessages.
type SendMessagesParams struct {
	// ContentLength The size of the complete payload in bytes.
	// This is used to determine if the payload needs to be
	// split into chunks and how.
	ContentLength int64 `json:"content-length"`

	// XAgrirouterIsPublish If set to true, the message will be sent as a published message
	// and any endpoints that are subscribed to the message type
	// would be able to receive it, provided other conditions for routing are met.
	XAgrirouterIsPublish bool `json:"x-agrirouter-is-publish"`

	// XAgrirouterDirectRecipients Comma-separated list of agrirouter endpoint IDs of the direct recipients.
	// Allows specifying direct recipients of the message, which
	// could receive it even if they are not subscribed to the message type.
	XAgrirouterDirectRecipients *[]openapi_types.UUID `json:"x-agrirouter-direct-recipients,omitempty"`

	// XAgrirouterSentTimestamp Client side timestamp of sending the data.
	XAgrirouterSentTimestamp time.Time `json:"x-agrirouter-sent-timestamp"`

	// XAgrirouterEndpointId The agrirouter endpoint ID of the sender.
	// This is the ID of the endpoint that is sending the message.
	XAgrirouterEndpointId openapi_types.UUID `json:"x-agrirouter-endpoint-id"`

	// XAgrirouterTeamsetContextId A teamset is a set of connected machines that work and move together
	// and are connected to the same (virtual) communication unit.
	// The machines in the teamset are typically connected physically and
	// informationally (for example via ISOBUS).
	XAgrirouterTeamsetContextId *string `json:"x-agrirouter-teamset-context-id,omitempty"`

	// XAgrirouterMessageType Message type of the sent data. See available types here:
	// https://docs.agrirouter.com/agrirouter-interface-documentation/latest/tmt/overview.html
	XAgrirouterMessageType string `json:"x-agrirouter-message-type"`

	// XAgrirouterTenantId The farmer's tenant ID in relation to which communication is done.
	XAgrirouterTenantId XAgrirouterTenantId `json:"x-agrirouter-tenant-id"`

	// XAgrirouterContextId Application side identifier of the sent data.
	// agrirouter will use this to generate application message id
	// and also will pass it on as chunk context id in case if the payload
	// had to be split into several messages.
	// This has to be generated by the application and be unique for
	// every sent payload. Applications may want to reuse the same id
	// in case if they are resending the same payload again, when f.e
	// retrying after a failure.
	XAgrirouterContextId string `json:"x-agrirouter-context-id"`

	// XAgrirouterFilename Optional name of the file that is attached to messages as metadata.
	XAgrirouterFilename *string `json:"x-agrirouter-filename,omitempty"`
}

// PutEndpointJSONRequestBody defines body for PutEndpoint for application/json ContentType.
type PutEndpointJSONRequestBody = PutEndpointRequest

// AsMessageReceivedEventData returns the union data inside the GenericEventData as a MessageReceivedEventData
func (t GenericEventData) AsMessageReceivedEventData() (MessageReceivedEventData, error) {
	var body MessageReceivedEventData
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromMessageReceivedEventData overwrites any union data inside the GenericEventData as the provided MessageReceivedEventData
func (t *GenericEventData) FromMessageReceivedEventData(v MessageReceivedEventData) error {
	v.EventType = "MessageReceivedEventData"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeMessageReceivedEventData performs a merge with any union data inside the GenericEventData, using the provided MessageReceivedEventData
func (t *GenericEventData) MergeMessageReceivedEventData(v MessageReceivedEventData) error {
	v.EventType = "MessageReceivedEventData"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsFileReceivedEventData returns the union data inside the GenericEventData as a FileReceivedEventData
func (t GenericEventData) AsFileReceivedEventData() (FileReceivedEventData, error) {
	var body FileReceivedEventData
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromFileReceivedEventData overwrites any union data inside the GenericEventData as the provided FileReceivedEventData
func (t *GenericEventData) FromFileReceivedEventData(v FileReceivedEventData) error {
	v.EventType = "FileReceivedEventData"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeFileReceivedEventData performs a merge with any union data inside the GenericEventData, using the provided FileReceivedEventData
func (t *GenericEventData) MergeFileReceivedEventData(v FileReceivedEventData) error {
	v.EventType = "FileReceivedEventData"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t GenericEventData) Discriminator() (string, error) {
	var discriminator struct {
		Discriminator string `json:"event_type"`
	}
	err := json.Unmarshal(t.union, &discriminator)
	return discriminator.Discriminator, err
}

func (t GenericEventData) ValueByDiscriminator() (interface{}, error) {
	discriminator, err := t.Discriminator()
	if err != nil {
		return nil, err
	}
	switch discriminator {
	case "FileReceivedEventData":
		return t.AsFileReceivedEventData()
	case "MessageReceivedEventData":
		return t.AsMessageReceivedEventData()
	default:
		return nil, errors.New("unknown discriminator value: " + discriminator)
	}
}

func (t GenericEventData) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *GenericEventData) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// Create or update endpoint
	// (PUT /endpoints/{externalId})
	PutEndpoint(ctx echo.Context, externalId string, params PutEndpointParams) error
	// Receive events from agrirouter outbox
	// (GET /events)
	ReceiveEvents(ctx echo.Context, params ReceiveEventsParams) error
	// Send one or several messages to agrirouter inbox
	// (POST /messages)
	SendMessages(ctx echo.Context, params SendMessagesParams) error
	// Download message payload from agrirouter
	// (GET /payloads/{messageId}/{messageReceivedAt})
	GetMessagePayload(ctx echo.Context, messageId openapi_types.UUID, messageReceivedAt time.Time) error
}

// ServerInterfaceWrapper converts echo contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler ServerInterface
}

// PutEndpoint converts echo context to params.
func (w *ServerInterfaceWrapper) PutEndpoint(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "externalId" -------------
	var externalId string

	err = runtime.BindStyledParameterWithOptions("simple", "externalId", ctx.Param("externalId"), &externalId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter externalId: %s", err))
	}

	ctx.Set(AgrirouterOauthQAScopes, []string{"endpoints:manage"})

	ctx.Set(AgrirouterOauthPRODScopes, []string{"endpoints:manage"})

	// Parameter object where we will unmarshal all parameters from the context
	var params PutEndpointParams

	headers := ctx.Request().Header
	// ------------- Required header parameter "x-agrirouter-tenant-id" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("x-agrirouter-tenant-id")]; found {
		var XAgrirouterTenantId XAgrirouterTenantId
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for x-agrirouter-tenant-id, got %d", n))
		}

		err = runtime.BindStyledParameterWithOptions("simple", "x-agrirouter-tenant-id", valueList[0], &XAgrirouterTenantId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: true})
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter x-agrirouter-tenant-id: %s", err))
		}

		params.XAgrirouterTenantId = XAgrirouterTenantId
	} else {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Header parameter x-agrirouter-tenant-id is required, but not found"))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.PutEndpoint(ctx, externalId, params)
	return err
}

// ReceiveEvents converts echo context to params.
func (w *ServerInterfaceWrapper) ReceiveEvents(ctx echo.Context) error {
	var err error

	ctx.Set(AgrirouterOauthQAScopes, []string{})

	ctx.Set(AgrirouterOauthPRODScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params ReceiveEventsParams
	// ------------- Optional query parameter "types" -------------

	err = runtime.BindQueryParameter("form", true, false, "types", ctx.QueryParams(), &params.Types)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter types: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.ReceiveEvents(ctx, params)
	return err
}

// SendMessages converts echo context to params.
func (w *ServerInterfaceWrapper) SendMessages(ctx echo.Context) error {
	var err error

	ctx.Set(AgrirouterOauthQAScopes, []string{})

	ctx.Set(AgrirouterOauthPRODScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params SendMessagesParams

	headers := ctx.Request().Header
	// ------------- Required header parameter "content-length" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("content-length")]; found {
		var ContentLength int64
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for content-length, got %d", n))
		}

		err = runtime.BindStyledParameterWithOptions("simple", "content-length", valueList[0], &ContentLength, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: true})
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter content-length: %s", err))
		}

		params.ContentLength = ContentLength
	} else {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Header parameter content-length is required, but not found"))
	}
	// ------------- Required header parameter "x-agrirouter-is-publish" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("x-agrirouter-is-publish")]; found {
		var XAgrirouterIsPublish bool
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for x-agrirouter-is-publish, got %d", n))
		}

		err = runtime.BindStyledParameterWithOptions("simple", "x-agrirouter-is-publish", valueList[0], &XAgrirouterIsPublish, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: true})
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter x-agrirouter-is-publish: %s", err))
		}

		params.XAgrirouterIsPublish = XAgrirouterIsPublish
	} else {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Header parameter x-agrirouter-is-publish is required, but not found"))
	}
	// ------------- Optional header parameter "x-agrirouter-direct-recipients" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("x-agrirouter-direct-recipients")]; found {
		var XAgrirouterDirectRecipients []openapi_types.UUID
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for x-agrirouter-direct-recipients, got %d", n))
		}

		err = runtime.BindStyledParameterWithOptions("simple", "x-agrirouter-direct-recipients", valueList[0], &XAgrirouterDirectRecipients, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter x-agrirouter-direct-recipients: %s", err))
		}

		params.XAgrirouterDirectRecipients = &XAgrirouterDirectRecipients
	}
	// ------------- Required header parameter "x-agrirouter-sent-timestamp" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("x-agrirouter-sent-timestamp")]; found {
		var XAgrirouterSentTimestamp time.Time
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for x-agrirouter-sent-timestamp, got %d", n))
		}

		err = runtime.BindStyledParameterWithOptions("simple", "x-agrirouter-sent-timestamp", valueList[0], &XAgrirouterSentTimestamp, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: true})
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter x-agrirouter-sent-timestamp: %s", err))
		}

		params.XAgrirouterSentTimestamp = XAgrirouterSentTimestamp
	} else {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Header parameter x-agrirouter-sent-timestamp is required, but not found"))
	}
	// ------------- Required header parameter "x-agrirouter-endpoint-id" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("x-agrirouter-endpoint-id")]; found {
		var XAgrirouterEndpointId openapi_types.UUID
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for x-agrirouter-endpoint-id, got %d", n))
		}

		err = runtime.BindStyledParameterWithOptions("simple", "x-agrirouter-endpoint-id", valueList[0], &XAgrirouterEndpointId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: true})
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter x-agrirouter-endpoint-id: %s", err))
		}

		params.XAgrirouterEndpointId = XAgrirouterEndpointId
	} else {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Header parameter x-agrirouter-endpoint-id is required, but not found"))
	}
	// ------------- Optional header parameter "x-agrirouter-teamset-context-id" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("x-agrirouter-teamset-context-id")]; found {
		var XAgrirouterTeamsetContextId string
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for x-agrirouter-teamset-context-id, got %d", n))
		}

		err = runtime.BindStyledParameterWithOptions("simple", "x-agrirouter-teamset-context-id", valueList[0], &XAgrirouterTeamsetContextId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter x-agrirouter-teamset-context-id: %s", err))
		}

		params.XAgrirouterTeamsetContextId = &XAgrirouterTeamsetContextId
	}
	// ------------- Required header parameter "x-agrirouter-message-type" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("x-agrirouter-message-type")]; found {
		var XAgrirouterMessageType string
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for x-agrirouter-message-type, got %d", n))
		}

		err = runtime.BindStyledParameterWithOptions("simple", "x-agrirouter-message-type", valueList[0], &XAgrirouterMessageType, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: true})
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter x-agrirouter-message-type: %s", err))
		}

		params.XAgrirouterMessageType = XAgrirouterMessageType
	} else {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Header parameter x-agrirouter-message-type is required, but not found"))
	}
	// ------------- Required header parameter "x-agrirouter-tenant-id" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("x-agrirouter-tenant-id")]; found {
		var XAgrirouterTenantId XAgrirouterTenantId
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for x-agrirouter-tenant-id, got %d", n))
		}

		err = runtime.BindStyledParameterWithOptions("simple", "x-agrirouter-tenant-id", valueList[0], &XAgrirouterTenantId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: true})
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter x-agrirouter-tenant-id: %s", err))
		}

		params.XAgrirouterTenantId = XAgrirouterTenantId
	} else {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Header parameter x-agrirouter-tenant-id is required, but not found"))
	}
	// ------------- Required header parameter "x-agrirouter-context-id" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("x-agrirouter-context-id")]; found {
		var XAgrirouterContextId string
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for x-agrirouter-context-id, got %d", n))
		}

		err = runtime.BindStyledParameterWithOptions("simple", "x-agrirouter-context-id", valueList[0], &XAgrirouterContextId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: true})
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter x-agrirouter-context-id: %s", err))
		}

		params.XAgrirouterContextId = XAgrirouterContextId
	} else {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Header parameter x-agrirouter-context-id is required, but not found"))
	}
	// ------------- Optional header parameter "x-agrirouter-filename" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("x-agrirouter-filename")]; found {
		var XAgrirouterFilename string
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for x-agrirouter-filename, got %d", n))
		}

		err = runtime.BindStyledParameterWithOptions("simple", "x-agrirouter-filename", valueList[0], &XAgrirouterFilename, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter x-agrirouter-filename: %s", err))
		}

		params.XAgrirouterFilename = &XAgrirouterFilename
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.SendMessages(ctx, params)
	return err
}

// GetMessagePayload converts echo context to params.
func (w *ServerInterfaceWrapper) GetMessagePayload(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "messageId" -------------
	var messageId openapi_types.UUID

	err = runtime.BindStyledParameterWithOptions("simple", "messageId", ctx.Param("messageId"), &messageId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter messageId: %s", err))
	}

	// ------------- Path parameter "messageReceivedAt" -------------
	var messageReceivedAt time.Time

	err = runtime.BindStyledParameterWithOptions("simple", "messageReceivedAt", ctx.Param("messageReceivedAt"), &messageReceivedAt, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter messageReceivedAt: %s", err))
	}

	ctx.Set(AgrirouterOauthQAScopes, []string{})

	ctx.Set(AgrirouterOauthPRODScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetMessagePayload(ctx, messageId, messageReceivedAt)
	return err
}

// This is a simple interface which specifies echo.Route addition functions which
// are present on both echo.Echo and echo.Group, since we want to allow using
// either of them for path registration
type EchoRouter interface {
	CONNECT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	DELETE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	GET(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	HEAD(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	OPTIONS(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PATCH(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	POST(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PUT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	TRACE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
}

// RegisterHandlers adds each server route to the EchoRouter.
func RegisterHandlers(router EchoRouter, si ServerInterface) {
	RegisterHandlersWithBaseURL(router, si, "")
}

// Registers handlers, and prepends BaseURL to the paths, so that the paths
// can be served under a prefix.
func RegisterHandlersWithBaseURL(router EchoRouter, si ServerInterface, baseURL string) {

	wrapper := ServerInterfaceWrapper{
		Handler: si,
	}

	router.PUT(baseURL+"/endpoints/:externalId", wrapper.PutEndpoint)
	router.GET(baseURL+"/events", wrapper.ReceiveEvents)
	router.POST(baseURL+"/messages", wrapper.SendMessages)
	router.GET(baseURL+"/payloads/:messageId/:messageReceivedAt", wrapper.GetMessagePayload)

}

type PutEndpointRequestObject struct {
	ExternalId string `json:"externalId"`
	Params     PutEndpointParams
	Body       *PutEndpointJSONRequestBody
}

type PutEndpointResponseObject interface {
	VisitPutEndpointResponse(w http.ResponseWriter) error
}

type PutEndpoint200JSONResponse Endpoint

func (response PutEndpoint200JSONResponse) VisitPutEndpointResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)

	return json.NewEncoder(w).Encode(response)
}

type PutEndpoint201JSONResponse Endpoint

func (response PutEndpoint201JSONResponse) VisitPutEndpointResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(201)

	return json.NewEncoder(w).Encode(response)
}

type PutEndpoint400Response struct {
}

func (response PutEndpoint400Response) VisitPutEndpointResponse(w http.ResponseWriter) error {
	w.WriteHeader(400)
	return nil
}

type PutEndpoint401Response struct {
}

func (response PutEndpoint401Response) VisitPutEndpointResponse(w http.ResponseWriter) error {
	w.WriteHeader(401)
	return nil
}

type PutEndpoint403Response struct {
}

func (response PutEndpoint403Response) VisitPutEndpointResponse(w http.ResponseWriter) error {
	w.WriteHeader(403)
	return nil
}

type PutEndpoint500Response struct {
}

func (response PutEndpoint500Response) VisitPutEndpointResponse(w http.ResponseWriter) error {
	w.WriteHeader(500)
	return nil
}

type PutEndpoint502Response struct {
}

func (response PutEndpoint502Response) VisitPutEndpointResponse(w http.ResponseWriter) error {
	w.WriteHeader(502)
	return nil
}

type PutEndpoint503Response struct {
}

func (response PutEndpoint503Response) VisitPutEndpointResponse(w http.ResponseWriter) error {
	w.WriteHeader(503)
	return nil
}

type PutEndpoint504Response struct {
}

func (response PutEndpoint504Response) VisitPutEndpointResponse(w http.ResponseWriter) error {
	w.WriteHeader(504)
	return nil
}

type ReceiveEventsRequestObject struct {
	Params ReceiveEventsParams
}

type ReceiveEventsResponseObject interface {
	VisitReceiveEventsResponse(w http.ResponseWriter) error
}

type ReceiveEvents200TexteventStreamResponse struct {
	Body          io.Reader
	ContentLength int64
}

func (response ReceiveEvents200TexteventStreamResponse) VisitReceiveEventsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "text/event-stream")
	if response.ContentLength != 0 {
		w.Header().Set("Content-Length", fmt.Sprint(response.ContentLength))
	}
	w.WriteHeader(200)

	if closer, ok := response.Body.(io.ReadCloser); ok {
		defer closer.Close()
	}
	_, err := io.Copy(w, response.Body)
	return err
}

type ReceiveEvents400Response struct {
}

func (response ReceiveEvents400Response) VisitReceiveEventsResponse(w http.ResponseWriter) error {
	w.WriteHeader(400)
	return nil
}

type ReceiveEvents401Response struct {
}

func (response ReceiveEvents401Response) VisitReceiveEventsResponse(w http.ResponseWriter) error {
	w.WriteHeader(401)
	return nil
}

type ReceiveEvents403Response struct {
}

func (response ReceiveEvents403Response) VisitReceiveEventsResponse(w http.ResponseWriter) error {
	w.WriteHeader(403)
	return nil
}

type ReceiveEvents500Response struct {
}

func (response ReceiveEvents500Response) VisitReceiveEventsResponse(w http.ResponseWriter) error {
	w.WriteHeader(500)
	return nil
}

type SendMessagesRequestObject struct {
	Params SendMessagesParams
	Body   io.Reader
}

type SendMessagesResponseObject interface {
	VisitSendMessagesResponse(w http.ResponseWriter) error
}

type SendMessages200Response struct {
}

func (response SendMessages200Response) VisitSendMessagesResponse(w http.ResponseWriter) error {
	w.WriteHeader(200)
	return nil
}

type SendMessages400Response struct {
}

func (response SendMessages400Response) VisitSendMessagesResponse(w http.ResponseWriter) error {
	w.WriteHeader(400)
	return nil
}

type SendMessages401Response struct {
}

func (response SendMessages401Response) VisitSendMessagesResponse(w http.ResponseWriter) error {
	w.WriteHeader(401)
	return nil
}

type SendMessages403Response struct {
}

func (response SendMessages403Response) VisitSendMessagesResponse(w http.ResponseWriter) error {
	w.WriteHeader(403)
	return nil
}

type SendMessages500Response struct {
}

func (response SendMessages500Response) VisitSendMessagesResponse(w http.ResponseWriter) error {
	w.WriteHeader(500)
	return nil
}

type GetMessagePayloadRequestObject struct {
	MessageId         openapi_types.UUID `json:"messageId"`
	MessageReceivedAt time.Time          `json:"messageReceivedAt"`
}

type GetMessagePayloadResponseObject interface {
	VisitGetMessagePayloadResponse(w http.ResponseWriter) error
}

type GetMessagePayload200ApplicationoctetStreamResponse struct {
	Body          io.Reader
	ContentLength int64
}

func (response GetMessagePayload200ApplicationoctetStreamResponse) VisitGetMessagePayloadResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/octet-stream")
	if response.ContentLength != 0 {
		w.Header().Set("Content-Length", fmt.Sprint(response.ContentLength))
	}
	w.WriteHeader(200)

	if closer, ok := response.Body.(io.ReadCloser); ok {
		defer closer.Close()
	}
	_, err := io.Copy(w, response.Body)
	return err
}

type GetMessagePayload400Response struct {
}

func (response GetMessagePayload400Response) VisitGetMessagePayloadResponse(w http.ResponseWriter) error {
	w.WriteHeader(400)
	return nil
}

type GetMessagePayload401Response struct {
}

func (response GetMessagePayload401Response) VisitGetMessagePayloadResponse(w http.ResponseWriter) error {
	w.WriteHeader(401)
	return nil
}

type GetMessagePayload403Response struct {
}

func (response GetMessagePayload403Response) VisitGetMessagePayloadResponse(w http.ResponseWriter) error {
	w.WriteHeader(403)
	return nil
}

type GetMessagePayload404Response struct {
}

func (response GetMessagePayload404Response) VisitGetMessagePayloadResponse(w http.ResponseWriter) error {
	w.WriteHeader(404)
	return nil
}

type GetMessagePayload500Response struct {
}

func (response GetMessagePayload500Response) VisitGetMessagePayloadResponse(w http.ResponseWriter) error {
	w.WriteHeader(500)
	return nil
}

// StrictServerInterface represents all server handlers.
type StrictServerInterface interface {
	// Create or update endpoint
	// (PUT /endpoints/{externalId})
	PutEndpoint(ctx context.Context, request PutEndpointRequestObject) (PutEndpointResponseObject, error)
	// Receive events from agrirouter outbox
	// (GET /events)
	ReceiveEvents(ctx context.Context, request ReceiveEventsRequestObject) (ReceiveEventsResponseObject, error)
	// Send one or several messages to agrirouter inbox
	// (POST /messages)
	SendMessages(ctx context.Context, request SendMessagesRequestObject) (SendMessagesResponseObject, error)
	// Download message payload from agrirouter
	// (GET /payloads/{messageId}/{messageReceivedAt})
	GetMessagePayload(ctx context.Context, request GetMessagePayloadRequestObject) (GetMessagePayloadResponseObject, error)
}

type StrictHandlerFunc = strictecho.StrictEchoHandlerFunc
type StrictMiddlewareFunc = strictecho.StrictEchoMiddlewareFunc

func NewStrictHandler(ssi StrictServerInterface, middlewares []StrictMiddlewareFunc) ServerInterface {
	return &strictHandler{ssi: ssi, middlewares: middlewares}
}

type strictHandler struct {
	ssi         StrictServerInterface
	middlewares []StrictMiddlewareFunc
}

// PutEndpoint operation middleware
func (sh *strictHandler) PutEndpoint(ctx echo.Context, externalId string, params PutEndpointParams) error {
	var request PutEndpointRequestObject

	request.ExternalId = externalId
	request.Params = params

	var body PutEndpointJSONRequestBody
	if err := ctx.Bind(&body); err != nil {
		return err
	}
	request.Body = &body

	handler := func(ctx echo.Context, request interface{}) (interface{}, error) {
		return sh.ssi.PutEndpoint(ctx.Request().Context(), request.(PutEndpointRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "PutEndpoint")
	}

	response, err := handler(ctx, request)

	if err != nil {
		return err
	} else if validResponse, ok := response.(PutEndpointResponseObject); ok {
		return validResponse.VisitPutEndpointResponse(ctx.Response())
	} else if response != nil {
		return fmt.Errorf("unexpected response type: %T", response)
	}
	return nil
}

// ReceiveEvents operation middleware
func (sh *strictHandler) ReceiveEvents(ctx echo.Context, params ReceiveEventsParams) error {
	var request ReceiveEventsRequestObject

	request.Params = params

	handler := func(ctx echo.Context, request interface{}) (interface{}, error) {
		return sh.ssi.ReceiveEvents(ctx.Request().Context(), request.(ReceiveEventsRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "ReceiveEvents")
	}

	response, err := handler(ctx, request)

	if err != nil {
		return err
	} else if validResponse, ok := response.(ReceiveEventsResponseObject); ok {
		return validResponse.VisitReceiveEventsResponse(ctx.Response())
	} else if response != nil {
		return fmt.Errorf("unexpected response type: %T", response)
	}
	return nil
}

// SendMessages operation middleware
func (sh *strictHandler) SendMessages(ctx echo.Context, params SendMessagesParams) error {
	var request SendMessagesRequestObject

	request.Params = params

	request.Body = ctx.Request().Body

	handler := func(ctx echo.Context, request interface{}) (interface{}, error) {
		return sh.ssi.SendMessages(ctx.Request().Context(), request.(SendMessagesRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "SendMessages")
	}

	response, err := handler(ctx, request)

	if err != nil {
		return err
	} else if validResponse, ok := response.(SendMessagesResponseObject); ok {
		return validResponse.VisitSendMessagesResponse(ctx.Response())
	} else if response != nil {
		return fmt.Errorf("unexpected response type: %T", response)
	}
	return nil
}

// GetMessagePayload operation middleware
func (sh *strictHandler) GetMessagePayload(ctx echo.Context, messageId openapi_types.UUID, messageReceivedAt time.Time) error {
	var request GetMessagePayloadRequestObject

	request.MessageId = messageId
	request.MessageReceivedAt = messageReceivedAt

	handler := func(ctx echo.Context, request interface{}) (interface{}, error) {
		return sh.ssi.GetMessagePayload(ctx.Request().Context(), request.(GetMessagePayloadRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "GetMessagePayload")
	}

	response, err := handler(ctx, request)

	if err != nil {
		return err
	} else if validResponse, ok := response.(GetMessagePayloadResponseObject); ok {
		return validResponse.VisitGetMessagePayloadResponse(ctx.Response())
	} else if response != nil {
		return fmt.Errorf("unexpected response type: %T", response)
	}
	return nil
}
